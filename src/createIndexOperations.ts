import * as fs from 'fs';
import * as path from 'path';
import { getAllowedSubfolders, hasPubspecYaml, shouldSkip } from './utils';

/**
 * Recursively generates or updates _index.dart files for the given directory using a bottom-up approach.
 *
 * Rules and Behavior:
 * 1. Processes subdirectories first before handling the current directory
 * 2. Skips generation if pubspec.yaml is present in the current directory
 * 3. Excludes files that match shouldSkip() criteria (e.g., generated files, test files)
 * 4. Only includes .dart files (excluding _index.dart itself)
 *
 * File Generation Rules:
 * - Creates/updates _index.dart only if there are valid exports
 * - Includes a timestamp in the generated file header
 * - Maintains proper newlines and formatting
 * - Exports both local .dart files and subdirectory _index.dart files
 *
 * @param dir The directory path to process
 * @param summary Optional object to track statistics of generated and updated files
 * @returns Boolean indicating if any Dart files were found/processed in this directory tree
 */
export async function generateIndexFiles(dir: string, summary?: { generated: number; updated: number; }): Promise<boolean> {
    const localSummary = summary || { generated: 0, updated: 0 };
    const subDirs = getAllowedSubfolders(dir);
    const subIndexExports: string[] = [];
    let hasProcessedDartFiles = false;

    // Process subdirectories first (bottom-up approach)
    // This ensures that nested _index.dart files are created before their exports are needed
    for (const subDir of subDirs) {
        const hasSubDirContent = await generateIndexFiles(subDir, localSummary);
        if (hasSubDirContent) {
            hasProcessedDartFiles = true;
            const subDirName = path.basename(subDir);
            const subIndexPath = path.join(subDir, '_index.dart');
            // Only add export statement if _index.dart exists in the subdirectory
            // This prevents broken exports if a subdirectory has no exportable content
            if (fs.existsSync(subIndexPath)) {
                subIndexExports.push(`export '${subDirName}/_index.dart';`);
            }
        }
    }

    // Skip _index.dart generation for directories containing pubspec.yaml
    // This prevents generating index files at the package root level
    if (hasPubspecYaml(dir)) {
        // Return true if there are subIndexExports to ensure parent directories include this package
        return subIndexExports.length > 0;
    }

    // Process Dart files in the current directory
    // Exclude files that match shouldSkip criteria and _index.dart itself
    const currentFolderName = path.basename(dir);
    const dartFiles = fs.readdirSync(dir)
        .filter(file => path.extname(file) === '.dart' && !shouldSkip(file) && file !== '_index.dart');

    let indexPath = path.join(dir, '_index.dart');
    // Remove the filter that excludes files with same name as folder
    let exportLines = dartFiles
        .map(file => `export '${file}';`)
        .join('\n');

    // Combine local file exports with subdirectory exports
    // Maintains proper spacing between different types of exports
    if (subIndexExports.length > 0) {
        exportLines += (exportLines ? '\n' : '') + subIndexExports.join('\n');
    }

    // Only generate/update _index.dart if there's actual content to export
    if (exportLines.trim().length > 0) {
        hasProcessedDartFiles = true;
        const timestamp = new Date().toLocaleString();
        const commentBlock = `/*
** Generated by Moinsen Flutter (www.moinsen.dev) at ${timestamp}
*/\n`;

        // Ensure consistent file formatting with trailing newline
        const content = commentBlock + exportLines + '\n';

        if (fs.existsSync(indexPath)) {
            fs.writeFileSync(indexPath, content, { encoding: 'utf8' });
            localSummary.updated += 1;
        } else {
            fs.writeFileSync(indexPath, content, { encoding: 'utf8' });
            localSummary.generated += 1;
        }
    }

    return hasProcessedDartFiles;
}